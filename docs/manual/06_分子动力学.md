# 分子动力学模拟

mlp-train 支持使用训练好的机器学习势能运行分子动力学（MD）模拟。本章节介绍如何使用 ASE 和 OpenMM 两种引擎进行 MD 模拟。

## 基本 MD 模拟

### 使用 ASE（默认）

```python
import mlptrain as mlt

# 准备系统
system = mlt.System(mlt.Molecule('water.xyz'), box=None)
gap = mlt.potentials.GAP('water', system=system)

# 训练（或加载已训练的模型）
gap.al_train(method_name='orca', temp=1000)

# 运行 MD 模拟
trajectory = mlt.md.run_mlp_md(
    configuration=system.random_configuration(),
    mlp=gap,
    fs=200,          # 模拟时间 200 fs
    temp=300,        # 温度 300 K
    dt=0.5,          # 时间步长 0.5 fs
    interval=10,     # 每 10 步保存一次
)
```

### 使用 OpenMM（仅 MACE）

```python
import mlptrain as mlt

system = mlt.System(mlt.Molecule('water.xyz'), box=None)
mace = mlt.potentials.MACE('water', system=system)

# 训练
mace.al_train(method_name='xtb', temp=500, md_program='OpenMM')

# 使用 OpenMM 运行 MD
trajectory = mlt.md_openmm.run_mlp_md_openmm(
    configuration=system.random_configuration(),
    mlp=mace,
    fs=2000,         # 模拟时间 2000 fs
    temp=300,        # 温度 300 K
    dt=0.5,          # 时间步长 0.5 fs
    interval=100,    # 每 100 步保存一次
)
```

## 参数详解

### 基本参数

- `configuration`：起始构型
- `mlp`：训练好的机器学习势能
- `temp`：温度（K），设为 0 则运行 NVE 模拟
- `dt`：时间步长（fs）
- `interval`：保存间隔（步数）

### 时间参数

可以使用不同的时间单位：

```python
# 使用 fs（飞秒）
trajectory = mlt.md.run_mlp_md(..., fs=200)

# 使用 ps（皮秒）
trajectory = mlt.md.run_mlp_md(..., ps=1)

# 使用 ns（纳秒）
trajectory = mlt.md.run_mlp_md(..., ns=0.1)
```

### 保存间隔

```python
# 使用步数
trajectory = mlt.md.run_mlp_md(..., interval=10)

# 使用时间单位
trajectory = mlt.md.run_mlp_md(..., save_fs=5)   # 每 5 fs 保存一次
trajectory = mlt.md.run_mlp_md(..., save_ps=0.1) # 每 0.1 ps 保存一次
```

### 初始温度

设置初始温度（用于初始化速度）：

```python
trajectory = mlt.md.run_mlp_md(
    ...,
    temp=300,        # 运行温度
    init_temp=500,  # 初始温度（用于初始化速度）
)
```

## NPT 系综（等温等压）

```python
trajectory = mlt.md.run_mlp_md(
    configuration=system.random_configuration(),
    mlp=gap,
    fs=200,
    temp=300,
    dt=0.5,
    interval=10,
    pressure=1.0,      # 压力（bar）
    compress=4.57e-5,  # 压缩率（bar⁻¹），水的典型值
)
```

**注意**：NPT 模拟目前仅在生产运行中实现，不在主动学习中使用。

## 约束

### ASE 约束

```python
from ase.constraints import FixBondLength, FixAngle

# 固定键长
constraint1 = FixBondLength(0, 1)  # 固定原子 0 和 1 之间的键长

# 固定角度
constraint2 = FixAngle(0, 1, 2)  # 固定原子 0-1-2 的角度

trajectory = mlt.md.run_mlp_md(
    ...,
    constraints=[constraint1, constraint2]
)
```

## 偏置势

### 简单偏置

```python
from mlptrain.sampling import Bias
from mlptrain.sampling.reaction_coord import AverageDistance

# 定义反应坐标（平均距离）
cv = AverageDistance(atom_idxs=[0, 1])

# 创建偏置（简谐势）
bias = Bias(cv, kappa=0.1, ref=2.0)  # 弹簧常数 0.1 eV/Å²，参考值 2.0 Å

trajectory = mlt.md.run_mlp_md(
    ...,
    bias=bias
)
```

### PLUMED 偏置

```python
from mlptrain.sampling import PlumedBias
from mlptrain.sampling.plumed import PlumedAverageCV

# 定义 PLUMED 集体变量
cv = PlumedAverageCV(atom_idxs=[0, 1])

# 创建 PLUMED 偏置
bias = PlumedBias(cvs=[cv])

trajectory = mlt.md.run_mlp_md(
    ...,
    bias=bias
)
```

## 键断裂/形成能量

在特定键方向添加额外能量：

```python
# 键断裂能量
bbond_energy = {(0, 1): 0.1}  # 在原子 0 和 1 之间添加 0.1 eV

# 键形成能量
fbond_energy = {(2, 3): 0.1}  # 在原子 2 和 3 之间添加 0.1 eV

trajectory = mlt.md.run_mlp_md(
    ...,
    bbond_energy=bbond_energy,
    fbond_energy=fbond_energy
)
```

## 重启模拟

从之前的轨迹继续模拟：

```python
trajectory = mlt.md.run_mlp_md(
    ...,
    restart_files=['trajectory.traj', 'simulation.state.xml']
)
```

## 轨迹分析

### 保存轨迹

```python
# 保存为 XYZ 格式
trajectory.save(filename='water_trajectory.xyz')

# 保存为其他格式（如果支持）
trajectory.save_xyz('water_trajectory.xyz')
```

### 比较预测与真实值

```python
# 计算真实能量和力（使用参考方法）
trajectory.compare(mlp=gap, method_name='orca')
```

这会生成：
- 能量对比图
- 力对比图
- 误差统计

### 访问轨迹数据

```python
# 访问特定构型
first_config = trajectory[0]
last_config = trajectory[-1]

# 迭代所有构型
for config in trajectory:
    print(f"时间: {config.time} fs")
    print(f"能量: {config.energy.predicted} eV")

# 获取所有能量
energies = [config.energy.predicted for config in trajectory]
```

### 绘制轨迹

```python
# 绘制能量随时间的变化
trajectory.plot()
```

## OpenMM 特定选项

### 选择平台

```python
trajectory = mlt.md_openmm.run_mlp_md_openmm(
    ...,
    platform='CUDA'  # 'CUDA', 'OpenCL', 'CPU', 'Reference'
)
```

如果不指定，会自动选择最快的可用平台（按顺序：CUDA > OpenCL > CPU > Reference）。

### 保存 PLUMED 设置

```python
trajectory = mlt.md_openmm.run_mlp_md_openmm(
    ...,
    write_plumed_setup=True  # 保存 PLUMED 输入文件为 plumed_setup.dat
)
```

## 周期性边界条件

对于溶液相系统：

```python
box = mlt.Box([20.0, 20.0, 20.0])
system = mlt.System(mlt.Molecule('water.xyz'), box=box)

# 确保构型有盒子信息
config = system.random_configuration()
config.box = box

trajectory = mlt.md.run_mlp_md(
    configuration=config,
    mlp=gap,
    fs=200,
    temp=300,
    dt=0.5,
    interval=10,
)
```

## 性能优化

### 并行计算

```python
# 设置使用的核心数
mlt.Config.n_cores = 10

# MD 模拟会自动使用配置的核心数
trajectory = mlt.md.run_mlp_md(...)
```

### 时间步长选择

- **小分子**：0.5 fs
- **中等分子**：1.0 fs
- **大分子**：2.0 fs（需谨慎）

### 保存频率

- **短时间模拟**：每 10-50 步保存一次
- **长时间模拟**：每 100-1000 步保存一次

## 常见问题

### 问题 1：能量不守恒

**可能原因**：
- 时间步长太大
- MLP 预测不准确

**解决方案**：
- 减小时间步长
- 重新训练 MLP，增加训练数据

### 问题 2：模拟崩溃

**可能原因**：
- 起始构型不合理
- 温度过高
- MLP 在未训练区域预测

**解决方案**：
- 使用能量最小化后的构型
- 降低温度
- 增加训练数据覆盖范围

### 问题 3：OpenMM 无法找到 GPU

**解决方案**：
```python
# 明确指定使用 CPU
trajectory = mlt.md_openmm.run_mlp_md_openmm(..., platform='CPU')
```

## 下一步

- 学习 [高级采样方法](07_高级采样.md)
- 查看 [示例教程](09_示例教程.md)
